/* 
  gpt_example.strings
  server_xcode_project

  Created by Julia Demura on 09/01/2023.
  
*/

The server reads the port number from the command line and sets up an address and port to listen on.
It creates a socket and sets it to non-blocking mode.
It binds the socket to the specified address and port.
It listens for incoming connections on the socket.
It sets up an epoll instance and adds the socket to it.
It enters an infinite loop, waiting for events on the epoll instance and handling them as they occur. If an incoming connection is received on the socket, it accepts the connection and adds the new client socket to the epoll instance. If data is received from a client, it echoes the data back to the client.



#include <cstdio>
#include <cstring>
#include <cerrno>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/epoll.h>
#include <poll.h>
#include <sys/event.h>

const int MAX_EVENTS = 64;
const int BACKLOG = 10;

int main(int argc, char *argv[]) {
  if (argc < 2) {
	fprintf(stderr, "Usage: %s PORT\n", argv[0]);
	return 1;
  }

  // Get port number from command line
  char *port = argv[1];

  // Set up address and port for server
  struct addrinfo hints;
  memset(&hints, 0, sizeof(hints));
  hints.ai_family = AF_INET;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_flags = AI_PASSIVE;

  struct addrinfo *result;
  int error = getaddrinfo(NULL, port, &hints, &result);
  if (error != 0) {
	fprintf(stderr, "Error: %s\n", gai_strerror(error));
	return 1;
  }

  // Create socket
  int sockfd = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
  if (sockfd < 0) {
	perror("Error creating socket");
	return 1;
  }

  // Set socket to non-blocking
  int flags = fcntl(sockfd, F_GETFL, 0);
  if (flags < 0) {
	perror("Error getting socket flags");
	return 1;
  }
  if (fcntl(sockfd, F_SETFL, flags | O_NONBLOCK) < 0) {
	perror("Error setting socket to non-blocking");
	return 1;
  }

  // Bind socket to address and port
	  if (bind(sockfd, result->ai_addr, result->ai_addrlen) < 0) {
		perror("Error binding socket to address");
		return 1;
	}
		  
		  freeaddrinfo(result);
		  
		  // Listen for incoming connections
		  if (listen(sockfd, BACKLOG) < 0) {
		  perror("Error listening for connections");
		  return 1;
		  }
		  
		  // Set up epoll
		  int epollfd = epoll_create(1);
		  if (epollfd < 0) {
		  perror("Error creating epoll instance");
		  return 1;
		  }
		  
		  struct epoll_event event;
		  event.events = EPOLLIN;
		  event.data.fd = sockfd;
		  if (epoll_ctl(epollfd, EPOLL_CTL_ADD, sockfd, &event) < 0) {
		  perror("Error adding socket to epoll instance");
		  return 1;
		  }
		  
		  // Set up array for epoll events
		  struct epoll_event events[MAX_EVENTS];
		  
		  // Set up array for poll events
		  struct pollfd pollfds[MAX_EVENTS];
		  pollfds[0].fd = sockfd;
		  pollf
		  while (true) {
			// Wait for events on epoll instance
			int num_events = epoll_wait(epollfd, events, MAX_EVENTS, -1);
			if (num_events < 0) {
			  perror("Error waiting for epoll events");
			  return 1;
			}

			// Handle events
			for (int i = 0; i < num_events; i++) {
			  int fd = events[i].data.fd;

			  // If event is on the listening socket, accept new connection
			  if (fd == sockfd) {
				struct sockaddr_storage client_addr;
				socklen_t client_addr_len = sizeof(client_addr);
				int client_fd = accept(sockfd, (struct sockaddr *) &client_addr, &client_addr_len);
				if (client_fd < 0) {
				  perror("Error accepting connection");
				  continue;
				}

				// Set client socket to non-blocking
				flags = fcntl(client_fd, F_GETFL, 0);
				if (flags < 0) {
				  perror("Error getting socket flags");
				  close(client_fd);
				  continue;
				}
				if (fcntl(client_fd, F_SETFL, flags | O_NONBLOCK) < 0) {
				  perror("Error setting socket to non-blocking");
				  close(client_fd);
				  continue;
				}

				// Add client socket to epoll instance
				event.events = EPOLLIN;
				event.data.fd = client_fd;
				if (epoll_ctl(epollfd, EPOLL_CTL_ADD, client_fd, &event) < 0) {
				  perror("Error adding socket to epoll instance");
				  close(client_fd);
				  continue;
				}
			  }
			  // If event is on a client socket, read data and echo it back
			  else {
				char buffer[1024];
				ssize_t num_bytes = recv(fd, buffer, sizeof(buffer), 0);
				if (num_bytes < 0) {
				  if (errno != EAGAIN && errno != EWOULDBLOCK) {
					perror("Error reading from socket");
					close(fd);
					epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, NULL);
				  }
				  continue;
				}
				if (num_bytes == 0) {
				  close(fd);
				  epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, NULL);
				  continue;
				}
				if (send(fd, buffer, num_bytes, 0) < 0) {
				  perror("Error writing to socket");
				  close(fd);
				  epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, NULL);
				  continue;
				}
			  }
			}
		  }

		  close(sockfd);

		  return 0;

		  
		  Certainly! Here is an updated step-by-step plan with pseudocode for a server using the allowed functions and either poll, epoll, or kqueue instead of select:
		  Parse the port number and other necessary command line arguments.
		  Set up the address and port for the server using the getaddrinfo function.
		  Create a socket using the socket function.
		  Bind the socket to the address and port using the bind function.
		  Set the socket to listen for incoming connections using the listen function.
		  Initialize the file descriptor sets for poll, epoll, or kqueue as appropriate.
		  Set up the timeout variable for poll or kqueue as appropriate.
		  Enter a loop to handle incoming connections and requests.
		  Inside the loop, call poll, epoll_wait, or kqueue as appropriate to wait for events on the file descriptors.
		  Check for events on the listening socket (incoming connection).
		  Accept the incoming connection using the accept function.
		  Add the new client socket to the file descriptor sets as appropriate.
		  Update the max_fd or kq variable as appropriate.
		  Check for events on the client sockets (incoming data).
		  Read data from the client socket using the recv function.
		  Parse the request and determine the necessary action to take.
		  Perform the necessary action, possibly using additional functions such as execve, dup, dup2, pipe, fork, and fcntl.
		  Send a response to the client using the send function.
		  Close the client socket and remove it from the file descriptor sets as appropriate.
		  Repeat the loop to handle additional incoming connections and requests.
		  Close the listening socket and exit the program.
		  This updated plan should be suitable for a general-purpose server implementation using either poll, epoll, or kqueue instead of select, as well as the other functions listed in your question. The specific details of how the server handles requests and performs actions will depend on the requirements of the server application.

