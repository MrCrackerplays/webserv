/* 
  info_serv.strings
  server_xcode_project

  Created by Julia Demura on 09/01/2023.
  
*/

Examples request:
//https://www.rfc-editor.org/rfc/rfc3986#section-3.2.3

GET /hello.txt HTTP/1.1
User-Agent: curl/7.64.1
Host: www.example.com
Accept-Language: en, mi


URI-reference = <URI-reference, see [URI], Section 4.1>
absolute-URI  = <absolute-URI, see [URI], Section 4.3>
relative-part = <relative-part, see [URI], Section 4.2>
authority     = <authority, see [URI], Section 3.2>
uri-host      = <host, see [URI], Section 3.2.2>
port          = <port, see [URI], Section 3.2.3>
path-abempty  = <path-abempty, see [URI], Section 3.3>
segment       = <segment, see [URI], Section 3.3>
query         = <query, see [URI], Section 3.4>

absolute-path = 1*( "/" segment )
partial-URI   = relative-part [ "?" query ]

http-URI = "http" "://" authority path-abempty [ "?" query ]


URI         = scheme ":" hier-part [ "?" query ] [ "#" fragment ]

	 hier-part   = "//" authority path-abempty
				 / path-absolute
				 / path-rootless
				 / path-empty

The scheme and path components are required, though the path may be
  empty (no characters).  When authority is present, the path must
  either be empty or begin with a slash ("/") character.  When
  authority is not present, the path cannot begin with two slash
  characters ("//").  These restrictions result in five different ABNF
  rules for a path (Section 3.3), only one of which will match any
  given URI reference.

  The following are two example URIs and their component parts:

		foo://example.com:8042/over/there?name=ferret#nose
		\_/   \______________/\_________/ \_________/ \__/
		 |           |            |            |        |
	  scheme     authority       path        query   fragment
		 |   _____________________|__
		/ \ /                        \
		urn:example:animal:ferret:nose


The authority component is preceded by a double slash ("//") and is
  terminated by the next slash ("/"), question mark ("?"), or number
  sign ("#") character, or by the end of the URI.

The query component is indicated by the first question
   mark ("?") character and terminated by a number sign ("#") character
   or by the end of the URI.

A
   fragment identifier component is indicated by the presence of a
   number sign ("#") character and terminated by the end of the URI.

	  fragment    = *( pchar / "/" / "?" )




================================================================================

"hardcoded"
SERVER_SOFTWARE=webserv/1.0
GATEWAY_INTERFACE=CGI/1.1
'means not sure'
"generated"
'SERVER_NAME'=localhost -> before 1st slash -> example Host: localhost:8011
SERVER_PROTOCOL=
//The name and revision of the information protcol this request came in with. Format: protocol/revision
SERVER_PORT=
//The port number to which the request was sent.
REQUEST_METHOD=
//The method with which the request was made. For HTTP, this is "GET", "HEAD", "POST", etc.
QUERY_STRING=
//The information which follows the ? in the URL which referenced this script. This is the query information. It should not be decoded in any fashion. This variable should always be set when there is query information, regardless of command line decoding.
CONTENT_TYPE=
//For queries which have attached information, such as HTTP POST and PUT, this is the content type of the data.
CONTENT_LENGTH=


SCRIPT_NAME=
//A virtual path to the script being executed, used for self-referencing URLs.

"need to figure out"
PATH_INFO=
//The extra path information, as given by the client. In other words, scripts can be accessed by their virtual pathname, followed by extra information at the end of this path. The extra information is sent as PATH_INFO. This information should be decoded by the server if it comes from a URL before it is passed to the CGI script.
PATH_TRANSLATED=
//The server provides a translated version of PATH_INFO, which takes the path and does any virtual-to-physical mapping to it.

REMOTE_HOST=
//The hostname making the request. If the server does not have this information, it should set REMOTE_ADDR and leave this unset.
REMOTE_ADDR=
//The IP address of the remote host making the request.
AUTH_TYPE
//If the server supports user authentication, and the script is protects, this is the protocol-specific authentication method used to validate the user.
REMOTE_USER
//If the server supports user authentication, and the script is protected, this is the username they have authenticated as.
REMOTE_IDENT
//If the HTTP server supports RFC 931 identification, then this variable will be set to the remote user name retrieved from the server. Usage of this variable should be limited to logging only.

plan

+   1. envp generator, learn about rest, make one I know


+   3. add on to parsing.

		add to the parsing search of the server where the resourse is located (in location/server maybe by the host header)
		- if none, it is 1st, if not found it is first
		- there can be multiple requests from client to different servers


+	3.1 check access change in parsing
		get closest location function takes path from http request and gives the
		-> get root function that gives physical root
		closest loc + get root -> this i can check as actuall resourse path

3.2 check if i have cgi match with method and if I need execve
cgi reference is vector of str
after I get cgi from request i can compare if this one will work for us
if the cgi I want to see closest location methods list and compare

4. methods:
POST can be upload, opposite of delete


'******************'How to test?'******************'
command "nc"
nc localhost [number of port] [-v for details]
command "curl"
curl localhost:[portnumber]



'******************QUESTIONS:******************'

Arguments [A configuration file]
Everything in C++ 98.
-- or cpp11?

'******************GENERAL******************'
//can you as simple as possible but in details explain me what is server
A server is a computer or device that provides a service to another computer or device, known as a client.
Servers are often used to host websites, store and manage data, and provide a variety of other services over a network. For example, a web server is a type of server that hosts websites and allows users to access them over the internet. A database server is a type of server that stores and manages data in a database.
There are many different types of servers, each designed to perform specific functions. Some servers are dedicated, meaning that they are used exclusively for one purpose, while others are more general-purpose and can be used for a variety of different functions.

//can you have a server without machine and why?
A server is a computer or device that provides a service to another computer or device, so it must necessarily be a physical machine of some kind. It is not possible to have a server without a machine.
However, it is possible to use software to create a virtual server, which is a software version of a physical server that runs on a host machine. A virtual server can be used to provide the same types of services as a physical server, but it is not a physical machine in and of itself.
Virtual servers are often used in cloud computing environments, where multiple virtual servers can be created and managed on a single physical host machine. This can be useful for scaling services and resources up or down as needed, and can also be more cost-effective than using multiple physical servers.


//why you do not use try and catch here:
//if (error != 0) {
//	fprintf(stderr, "Error: %s\n", gai_strerror(error));
//	return 1;
// }

The try and catch statements in C++ are used to handle exceptions, which are runtime errors that occur during the execution of a program. The try block contains the code that may throw an exception, and the catch block contains the code that handles the exception.

In the code you provided, the getaddrinfo function is called to set up an address and port for the server to listen on. If the function fails, it returns a non-zero error code and sets the error variable to the specific error code. This error code is then passed to the gai_strerror function, which returns a string describing the error. The error message is then printed to stderr and the program exits with a return value of 1.

Exceptions are typically used to handle errors that are not easily anticipated and cannot be handled in a simple way, such as out-of-memory errors or invalid input. In this case, the error is anticipated (the getaddrinfo function is expected to return an error code if it fails) and is handled in a straightforward way by printing an error message and exiting the program. Therefore, it is not necessary to use try and catch statements in this case.

//
The line if "(fds[0].revents & POLLIN) " is checking if the POLLIN event has occurred on the file descriptor stored in the first element of the fds array.

The & operator is a bitwise AND operator in C++, it compares each bit of the first operand to the corresponding bit of the second operand. If both bits are 1, the corresponding result bit is set to 1, otherwise, the result bit is set to 0.

In this case, its used to check if the POLLIN event has occurred by comparing the revents field of the pollfd struct with the POLLIN constant. The POLLIN constant has a value of 0x001, which corresponds to the first bit being set.

The & operator compares the revents field to the POLLIN constant and returns true if the first bit of the revents field is set (i.e., the POLLIN event has occurred), otherwise, it returns false.

So this line of code is checking if the event POLLIN occurred on the file descriptor stored in the first element of the fds array, if it did it will enter the if statement block.

Its important to note that poll can return multiple events at the same time, so a bitwise AND operator is used to check if a specific event occurred.


'******************'"status_codes"'******************'

There are many different HTTP status codes, each with its own specific meaning. Here are some of the most common status codes and their meanings:

1xx (Informational): These status codes indicate that the server has received the request and is continuing to process it.

2xx (Success): These status codes indicate that the request was successfully received, understood, and processed.

	200 (OK): The request was successful, and the server is returning the requested data in the response body.
	201 (Created): The request was successful, and a new resource has been created as a result.
	204 (No Content): The request was successful, but there is no data to return in the response body.

3xx (Redirection): These status codes indicate that the client must take additional action to complete the request.

	301 (Moved Permanently): The requested resource has been permanently moved to a new URL.
	302 (Found): The requested resource has been temporarily moved to a new URL.
	304 (Not Modified): The client has made a conditional request, and the server has indicated that the data has not been modified since the client last requested it.

4xx (Client Error): These status codes indicate that there was an error on the client side of the request.

	400 (Bad Request): The request was malformed or invalid.
	401 (Unauthorized): The client must provide authentication credentials in order to access the requested resource.
	404 (Not Found): The requested resource could not be found on the server.

5xx (Server Error): These status codes indicate that there was an error on the server side of the request.

	500 (Internal Server Error): There was an internal server error that prevented the request from being processed.
	503 (Service Unavailable): The server is currently unable to handle the request.



'******************FUNCTIONS******************'

known:
execve,
dup,dup2,
pipe,
strerror,
errno,
fork,

******************"gai_strerror"**********************

The gai_strerror function is a library function in C++ that is used to convert error codes returned by the getaddrinfo function into human-readable error messages.

The getaddrinfo function is used to resolve domain names (such as "www.example.com") into numerical IP addresses. It can return a variety of error codes if it is unable to resolve the domain name for any reason.

The gai_strerror function takes an error code as an argument and returns a pointer to a null-terminated string that describes the error. Here is an example of how you might use the gai_strerror function:

#include <cstdio>
#include <cstring>
#include <cerrno>
#include <netdb.h>

int main() {
  int error;
  struct addrinfo *result;

  error = getaddrinfo("www.example.com", NULL, NULL, &result);
  if (error != 0) {
	fprintf(stderr, "Error: %s\n", gai_strerror(error));
	return 1;
  }

  // Use the addrinfo structure here...

  freeaddrinfo(result);
  return 0;
}

If the getaddrinfo function is unable to resolve the domain name, the gai_strerror function will be called to convert the error code into a human-readable error message that is printed to the standard error stream (stderr).

***********************"htons"*******************************
*******************"htonl, ntohs, ntohl,"********************

The htons, htonl, ntohs, and ntohl functions are all related to network byte order, which is the way that numerical values are represented in network communication. These functions are used to convert values between host byte order (the way that values are represented on the current machine) and network byte order.

It is generally a good idea to learn about these functions together, because they are closely related and are often used in conjunction with each other. Here is a brief overview of each function:

htons stands for "host to network short." It converts a 16-bit (short) value from host byte order to network byte order.
htonl stands for "host to network long." It converts a 32-bit (long) value from host byte order to network byte order.
ntohs stands for "network to host short." It converts a 16-bit (short) value from network byte order to host byte order.
ntohl stands for "network to host long." It converts a 32-bit (long) value from network byte order to host byte order.

These functions are often used when sending or receiving numerical data over a network, to ensure that the data is correctly interpreted by the recipient.

//Host byte order refers to the way that numerical values are represented on a particular machine. It is dependent on the architecture of the machine, specifically the order in which the bytes of a numerical value are stored in memory.

//For example, on a machine with a "little-endian" architecture, the least significant byte (the one with the lowest address) is stored first, followed by the next most significant byte, and so on. On a machine with a "big-endian" architecture, the most significant byte is stored first, followed by the next least significant byte, and so on.

//Network byte order is a standardized way of representing numerical values that is used in network communication. It is defined as "big-endian," which means that the most significant byte is stored first, followed by the next least significant byte, and so on.

//The htons, htonl, ntohs, and ntohl functions are used to convert values between host byte order and network byte order. These functions are often used when sending or receiving numerical data over a network, to ensure that the data is correctly interpreted by the recipient.
***************************************************************


OR
*****************"select, poll, epoll (epoll_create, epoll_ctl,
epoll_wait), kqueue (kqueue, kevent)," *****************

The select function is a way for a program to monitor multiple file descriptor sources for events, such as incoming data or the availability of space to write data. It takes three sets of file descriptors as arguments: those for reading, those for writing, and those for error conditions. It waits for events on these file descriptors and returns the count of file descriptors that are ready for the requested I/O.

The poll function is similar to select, but it uses an array of pollfd structures to specify the file descriptors to be monitored. It also has a timeout parameter, which specifies the maximum amount of time to wait for events.

The epoll function is similar to select and poll, but it is designed to scale better to large numbers of file descriptors. It uses an "epoll instance" to monitor file descriptors for events. The epoll_create function is used to create an epoll instance, and the epoll_ctl function is used to add or remove file descriptors from the instance. The epoll_wait function is used to wait for events on the epoll instance.

The kqueue function is similar to epoll, and is used to monitor file descriptor sources for events. The kqueue function creates a "kqueue instance", and the kevent function is used to add or remove file descriptors from the instance and to wait for events.


//which of them is better when making a server?
There is no one best function for monitoring file descriptor sources and waiting for events when creating a server. The choice of which function to use will depend on a variety of factors, including the specific requirements of the server, the hardware and operating system it is running on, and the level of performance and scalability needed.

Here are a few general points to consider when choosing which function to use:

The "select" function is relatively easy to use, but it has some limitations. It can only monitor file descriptors with a small integer value (typically 1024 or less), and it can be inefficient for large numbers of file descriptors.

The "poll" function is similar to select, but it is more scalable and can handle a larger number of file descriptors. It also has a timeout parameter, which can be useful for implementing timeouts or other types of time-based behavior.

The "epoll" function is more efficient than select or poll for large numbers of file descriptors, and it is able to scale well to very large numbers of file descriptors. It also supports edge-triggered behavior, which can be more efficient in some cases.

The "kqueue" function is similar to epoll, and it also scales well to large numbers of file descriptors. It is available on certain Unix-like operating systems, such as FreeBSD and macOS.

Ultimately, the choice of which function to use will depend on the specific requirements of your server and the trade-offs you are willing to make in terms of performance, scalability, and complexity. It is often a good idea to benchmark and compare the different options to see which one performs best in your particular case.

//so kqueue function is an option only on mac?
The kqueue function is available on certain Unix-like operating systems, such as FreeBSD and macOS. It is not available on all operating systems, and is typically not an option on systems that use the Linux kernel or other kernels.

If you are running your server on a system that does not support kqueue, you will need to choose a different function for monitoring file descriptor sources and waiting for events. Some options to consider include select, poll, and epoll.

*****************************************************************



accept,
listen,
send,
recv,

************'setsockopt'*************
#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>

int main() {
  int sock = socket(AF_INET, SOCK_STREAM, 0);

  int reuse = 1;
  setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));

  //SOL_SOCKET: This flag specifies that the options being set are at the socket level.
  //SO_REUSEADDR: This flag enables the reuse of local addresses. When this option is set on a socket, the system will allow the socket to bind to an address that is already in use by another socket. This can be useful when you want to reuse a socket without having to wait for the socket to time out.

  return 0;
}
This code creates a socket using the socket function and then sets the SO_REUSEADDR option using the setsockopt function to allow the socket to be reused.


If you are limited to using only the setsockopt function, you can use the following workaround:
Set the SO_LINGER option on the socket. You can set the l_onoff field to 0 to disable the linger, and the l_linger field to 0 to close the socket immediately.
Set the SO_REUSEADDR option on the socket. This will allow you to reuse the socket address immediately after the socket is closed.
Here's an example code:

#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main() {
  int sock = socket(AF_INET, SOCK_STREAM, 0);
  struct linger ling = {0, 0};
  setsockopt(sock, SOL_SOCKET, SO_LINGER, &ling, sizeof(linger));

  int reuse = 1;
  setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(int));

  return 0;
}
This code sets the SO_LINGER and SO_REUSEADDR options on the socket using the setsockopt function. The SO_LINGER option will cause the socket to be closed immediately, and the SO_REUSEADDR option will allow the socket address to be reused immediately after the socket is closed.


*************************************************************************

getsockname,
getprotobyname,


connect,

*****************"bind"**********************************
//https://man7.org/linux/man-pages/man2/bind.2.html
The bind() function binds a unique local name to the socket with descriptor socket. After calling socket(), a descriptor does not have a name associated with it. However, it does belong to a particular address family as specified when socket() is called. The exact format of a name depends on the address family.






*****************"getaddrinfo, freeaddrinfo,"*******************
//getaddrinfo, freeaddrinfo, gai_strerror - network address and service translation
//https://cppsecrets.com/users/18989711511997116104103495564103109971051084699111109/C00-Socket-Programming-getaddrinfo.php
//https://man7.org/linux/man-pages/man3/getaddrinfo.3.html

//The getaddrinfo() function is used to translate hostnames and service names into a socket address structure, which can be used to create a socket for the server.

*****************   "socket" ***************** //https://pubs.opengroup.org/onlinepubs/009604499/functions/socket.html
The socket() function shall create an unbound socket in a communications domain, and return a file descriptor that can be used in later function calls that operate on sockets.

The socket() function takes the following arguments:

domain
Specifies the communications domain in which a socket is to be created.
type
Specifies the type of socket to be created.
protocol
Specifies a particular protocol to be used with the socket. Specifying a protocol of 0 causes socket() to use an unspecified default protocol appropriate for the requested socket type.
->> this is defined in 'addrinfo' struct

*****************"fcntl"**********************************
//https://linux.die.net/man/3/fcntl
The fcntl function in C++ is a system call that provides control over file descriptor. It is defined in the <fcntl.h> header. The function takes three arguments: the file descriptor, the command to be executed, and an optional third argument, which is typically a pointer to a data structure used by the command. Some of the common commands that can be passed to fcntl include:

F_DUPFD - Duplicate the file descriptor
F_GETFD - Get the file descriptor flags
F_SETFD - Set the file descriptor flags
F_GETFL - Get the file status flags
F_SETFL - Set the file status flags
F_GETOWN - Get the process or process group ID currently receiving SIGIO and SIGURG signals
F_SETOWN - Set the process or process group ID to receive SIGIO and SIGURG signals
It returns the new file descriptor on success and -1 on failure.

The fcntl function can be used to perform various operations on a file descriptor, such as duplicating it, changing its flags, or setting its owner. it is useful when working with file descriptor in low level io operations.


'Non-blocking file descriptors' are often used in servers to handle multiple connections simultaneously.

When a server is using blocking file descriptors, it can only handle one connection at a time. For example, if a client is sending a large amount of data to the server, the server will be blocked and cannot process any other client connections until the data transfer is complete. This can lead to poor performance and slow response times for other clients trying to connect to the server.

By using non-blocking file descriptors, a server can continue to handle other connections while it is waiting for data to be sent or received on a particular file descriptor. This allows the server to handle multiple connections simultaneously, improving its overall performance and responsiveness.

Non-blocking file descriptor also helps when server is waiting for a response from the client, in case if the client is not responding server can continue to serve other clients instead of waiting for the response.

In summary, using non-blocking file descriptors allows a server to handle multiple connections simultaneously, improving its performance and responsiveness.
