/* 
  funct_explanations.strings
  server_xcode_project

  Created by Julia Demura on 19/01/2023.
  
*/


//#include "Socket.hpp"

int		Socket::getSocketFd(){
	return _socketFd;
}

Socket::Socket(void *inp) : Port(inp){
	
	_socketFd = socket(_res->ai_family, _res->ai_socktype, _res->ai_protocol);
	if (_socketFd < 0){
		throw std::runtime_error("Socket : socket");
//		perror("failed to create socket: socket");
//		exit(1);
	}
}

Socket::~Socket(){
	
	//not sure if here I should close socket fd
	close(_socketFd);
}

//setting the file descriptor associated with the socket (sockfd) to non-blocking mode. The fcntl function is used to modify the properties of the file descriptor.
//F_SETFL: set the file status flags.
//flags | O_NONBLOCK: This is the new value for the file status flags. flags is the value retrieved from the previous fcntl(sockfd, F_GETFL, 0) call. O_NONBLOCK is a constant defined in the <fcntl.h> header, it sets the non-blocking mode on the file descriptor.
//The | operator is a bitwise OR operator. It sets the bit of O_NONBLOCK to 1, while keeping the current value of other flags (flags) intact.
void	Socket::setToNonBlocking(){
	
	int flagsForFd = fcntl(_socketFd, F_GETFL, 0);
	if (flagsForFd < 0){
		throw std::runtime_error("Socket : fcntl");
//		perror("failed to create socket: fcntl");
//		exit(1);
	}
	if (fcntl(_socketFd, F_SETFL, flagsForFd | O_NONBLOCK) < 0){
		throw std::runtime_error("Socket : fcntl");
//		perror("failed to create socket: fcntl");
//		exit(1);
	}
}

//When a socket is created with socket(2), it exists in a name space (address family) but has no address assigned to it.
//bind() assigns the address specified by addr to the socket referred to by the file descriptor sockfd.  addrlen specifies the size, in bytes, of the address structure pointed to by addr. Traditionally, this operation is called “assigning a name to a socket”.
void	Socket::bindToPort(){
	
	if (bind(_socketFd, _res->ai_addr, _res->ai_addrlen) < 0){
		throw std::runtime_error("Socket : bind");
	}
	
}

//A backlog argument of 0 may allow the socket to accept connections, in which case the length of the listen queue may be set to an implementation-defined minimum value.
void	Socket::setToListen(){
	
	if (listen(_socketFd, 2) < 0){
		throw std::runtime_error("Socket : bind");
//		perror("error in socket: listen");
//		exit(1);
	}
}


void	Socket::acceptServ(){

	int client_socket = accept(_socketFd, NULL, NULL);
	if (client_socket < 0){
	///printf("err %s : %i\n", strerror(errno), errno);
		throw std::runtime_error("Socket : accept");
			//[EAGAIN] The socket is marked non-blocking, and the receive operation would block, or a receive timeout had been set, and the timeout expired before data were received.
		}
	
	///The error code "Resource temporarily unavailable" (errno value 35) can occur when calling the accept function in a non-blocking socket. This error indicates that the socket is in non-blocking mode and there are no incoming connections to be accepted at the moment.
	///When the socket is in non-blocking mode, the accept function returns immediately with the error code EAGAIN or EWOULDBLOCK (both have the same value) when there are no incoming connections to be accepted. In this case, you can use the select, poll or epoll system call to wait for incoming connections before calling accept again

}

//https://pubs.opengroup.org/onlinepubs/9699919799/
//Returns -1 if an error occurred
//Returns 0 if no descriptors are ready before the timer expires
//Otherwise returns the number of descriptors that have nonzero revents members
//POLLIN - Data is ready to recv() on this socket
//POLLOUT - Can send() to this socket without blocking
//POLLERR - Error on socket
//POLLHUP - Remote connection hanged up
//POLLNVAL - Error with socket descriptor

void Socket::pollSet(){
	
	//int poll(struct pollfd fds[], nfds_t nfds, int timeout);
	
	
	struct pollfd fds;//can be array if needed
	fds.fd = _socketFd; ///poll will manage this socket, recognize it by ID
	fds.events = POLLIN; //for incoming events
	// I maybe need to be able to write and read at once
	
	int res = poll(&fds, 1, -1);
	//perror("CHECK poll");
	
	if (fds.revents == POLLHUP)/// flags set, these flags indicate that the socket has a hangup error, a error or an invalid request respectively.)
		perror("POLLHUP poll revents");
	else if (fds.revents == POLLERR)
		perror("POLLERR poll revents");
	else if (fds.revents == POLLNVAL)
		perror("POLLNVAL poll revents");
	
	if (res < 0){
		throw std::runtime_error("Socket : poll");
	} else if (res == 0){
		//Returns 0 if no descriptors are ready before the timer expires
		throw std::runtime_error("Socket : poll no FD");
	} else {
		
		if (fds.revents & POLLIN){
			///one or more file descriptors have events available.
			///The code checks if the revents field of the fds struct contains the POLLIN flag,
			///which indicates that the file descriptor has incoming data.

		}
	}
}
